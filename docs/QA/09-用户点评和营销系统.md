# é—®é¢˜9: ç›®å‰æ˜¯å¦è®¾è®¡æœ‰ç”¨æˆ·çš„ç‚¹è¯„ç³»ç»Ÿï¼Œæ˜¯å¦å…³è”ç”¨æˆ·çš„é‚®ç®±åç»­å¯ä»¥ä½œä¸ºè¥é”€æ¨é€ï¼Ÿ

## å½“å‰çŠ¶æ€

### ç”¨æˆ·ç‚¹è¯„ç³»ç»Ÿï¼šâŒ æœªå®ç°

é¡¹ç›®**æ²¡æœ‰å†…ç½®çš„æ–‡ç« è¯„è®ºæˆ–ç‚¹è¯„ç³»ç»Ÿ**ã€‚

### é‚®ç®±è¥é”€ç³»ç»Ÿï¼šâœ… éƒ¨åˆ†å®ç°

é¡¹ç›®å·²æœ‰**æ–°é—»è®¢é˜…ï¼ˆNewsletterï¼‰ç³»ç»Ÿ**ï¼Œå¯ä»¥ä½œä¸ºé‚®ç®±è¥é”€çš„åŸºç¡€ã€‚

---

## 1. æ–°é—»è®¢é˜…ç³»ç»Ÿï¼ˆå·²å®ç°ï¼‰

### 1.1 ç°æœ‰åŠŸèƒ½

**æ–‡ä»¶ä½ç½®**: `src/newsletter/`

**æ ¸å¿ƒåŠŸèƒ½**ï¼š
```typescript
// è®¢é˜…ç®¡ç†
export const subscribe = async (email: string): Promise<boolean>
export const unsubscribe = async (email: string): Promise<boolean>
export const isSubscribed = async (email: string): Promise<boolean>
```

**æä¾›å•†**: Resend

**é…ç½®** (`src/config/website.tsx`):
```typescript
newsletter: {
  enable: true,
  provider: 'resend',
  autoSubscribeAfterSignUp: true,  // ç”¨æˆ·æ³¨å†Œæ—¶è‡ªåŠ¨è®¢é˜…
}
```

### 1.2 è‡ªåŠ¨è®¢é˜…æœºåˆ¶

**ç”¨æˆ·æ³¨å†Œæ—¶è‡ªåŠ¨è®¢é˜…**ï¼š

```typescript
// src/lib/auth.ts ä¸­çš„é’©å­
databaseHooks: {
  user: {
    create: {
      after: async (user) => {
        // è‡ªåŠ¨è®¢é˜…æ–°é—»é€šè®¯
        if (websiteConfig.newsletter.autoSubscribeAfterSignUp) {
          await subscribe(user.email);
        }
      },
    },
  },
}
```

**Server Actions**ï¼š
```typescript
// src/actions/subscribe-newsletter.ts
export const subscribeNewsletterAction = actionClient
  .schema(z.object({ email: z.string().email() }))
  .action(async ({ parsedInput }) => {
    const success = await subscribe(parsedInput.email);
    return { success };
  });

// src/actions/unsubscribe-newsletter.ts
export const unsubscribeNewsletterAction = actionClient
  .schema(z.object({ email: z.string().email() }))
  .action(async ({ parsedInput }) => {
    const success = await unsubscribe(parsedInput.email);
    return { success };
  });
```

### 1.3 è®¢é˜…è¡¨å•ç»„ä»¶

**ä½ç½®**: åšå®¢é¡µé¢ã€é¦–é¡µç­‰

```typescript
// ç¤ºä¾‹è®¢é˜…è¡¨å•
'use client';

import { useState } from 'react';
import { subscribeNewsletterAction } from '@/actions/subscribe-newsletter';

export function NewsletterForm() {
  const [email, setEmail] = useState('');
  const [status, setStatus] = useState<'idle' | 'loading' | 'success' | 'error'>('idle');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setStatus('loading');

    const result = await subscribeNewsletterAction({ email });

    if (result?.data?.success) {
      setStatus('success');
    } else {
      setStatus('error');
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        placeholder="your@email.com"
        required
      />
      <button type="submit" disabled={status === 'loading'}>
        Subscribe
      </button>
      {status === 'success' && <p>âœ… è®¢é˜…æˆåŠŸï¼</p>}
      {status === 'error' && <p>âŒ è®¢é˜…å¤±è´¥ï¼Œè¯·é‡è¯•</p>}
    </form>
  );
}
```

---

## 2. æ·»åŠ è¯„è®ºç³»ç»Ÿ

### 2.1 æ¨èæ–¹æ¡ˆ

ç”±äºè¯„è®ºç³»ç»Ÿè¾ƒä¸ºå¤æ‚ï¼Œæ¨èä½¿ç”¨**ç¬¬ä¸‰æ–¹æœåŠ¡**ï¼š

#### æ–¹æ¡ˆ1: Giscusï¼ˆæ¨èï¼ŒåŸºäº GitHub Discussionsï¼‰

**ä¼˜åŠ¿**ï¼š
- âœ… å®Œå…¨å…è´¹
- âœ… åŸºäº GitHub Discussions
- âœ… æ”¯æŒ Markdown
- âœ… æ”¯æŒååº”ï¼ˆğŸ‘â¤ï¸ç­‰ï¼‰
- âœ… æ”¯æŒå¤šè¯­è¨€
- âœ… æ— éœ€æ•°æ®åº“
- âœ… å¼€æº

**å®‰è£…æ­¥éª¤**ï¼š

```bash
pnpm add @giscus/react
```

**é…ç½®**ï¼š

1. åœ¨ GitHub ä»“åº“å¯ç”¨ Discussions
2. è®¿é—® https://giscus.app/ é…ç½®
3. è·å–é…ç½®å‚æ•°

**å®ç°**ï¼š

```typescript
// src/components/comments/giscus-comments.tsx
'use client';

import Giscus from '@giscus/react';
import { useLocale } from 'next-intl';

export function GiscusComments() {
  const locale = useLocale();

  return (
    <div className="mt-16">
      <Giscus
        id="comments"
        repo="your-username/your-repo"
        repoId="YOUR_REPO_ID"
        category="Comments"
        categoryId="YOUR_CATEGORY_ID"
        mapping="pathname"
        strict="0"
        reactionsEnabled="1"
        emitMetadata="0"
        inputPosition="top"
        theme="preferred_color_scheme"
        lang={locale}
        loading="lazy"
      />
    </div>
  );
}
```

**æ·»åŠ åˆ°æ–‡ç« é¡µé¢**ï¼š

```typescript
// src/app/[locale]/blog/[slug]/page.tsx
import { GiscusComments } from '@/components/comments/giscus-comments';

export default async function BlogPost({ params }) {
  const post = await getPost(params.slug);

  return (
    <article>
      {/* æ–‡ç« å†…å®¹ */}
      <div className="prose">{post.content}</div>

      {/* è¯„è®ºåŒº */}
      <GiscusComments />
    </article>
  );
}
```

---

#### æ–¹æ¡ˆ2: Disqusï¼ˆæœ€æµè¡Œï¼‰

**ä¼˜åŠ¿**ï¼š
- åŠŸèƒ½å¼ºå¤§
- ç¤¾åŒºæ´»è·ƒ
- åƒåœ¾è¯„è®ºè¿‡æ»¤

**ç¼ºç‚¹**ï¼š
- æœ‰å¹¿å‘Šï¼ˆå…è´¹ç‰ˆï¼‰
- åŠ è½½è¾ƒæ…¢
- éšç§é—®é¢˜

**å®ç°**ï¼š

```typescript
// src/components/comments/disqus-comments.tsx
'use client';

import { DiscussionEmbed } from 'disqus-react';

export function DisqusComments({ postId, title, url }) {
  const disqusShortname = process.env.NEXT_PUBLIC_DISQUS_SHORTNAME;

  return (
    <DiscussionEmbed
      shortname={disqusShortname}
      config={{
        url,
        identifier: postId,
        title,
      }}
    />
  );
}
```

---

#### æ–¹æ¡ˆ3: Utterancesï¼ˆåŸºäº GitHub Issuesï¼‰

**ä¼˜åŠ¿**ï¼š
- å®Œå…¨å…è´¹
- è½»é‡çº§
- æ— å¹¿å‘Š
- åŸºäº GitHub Issues

**å®ç°**ï¼š

```typescript
// src/components/comments/utterances-comments.tsx
'use client';

import { useEffect, useRef } from 'react';

export function UtterancesComments() {
  const commentsRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const script = document.createElement('script');
    script.src = 'https://utteranc.es/client.js';
    script.setAttribute('repo', 'your-username/your-repo');
    script.setAttribute('issue-term', 'pathname');
    script.setAttribute('theme', 'github-light');
    script.setAttribute('crossorigin', 'anonymous');
    script.async = true;

    commentsRef.current?.appendChild(script);
  }, []);

  return <div ref={commentsRef} />;
}
```

---

#### æ–¹æ¡ˆ4: è‡ªå»ºè¯„è®ºç³»ç»Ÿ

å¦‚æœéœ€è¦å®Œå…¨æ§åˆ¶ï¼Œå¯ä»¥è‡ªå»ºï¼š

**æ•°æ®åº“ Schema**ï¼š

```typescript
// src/db/schema.ts
export const comment = pgTable('comment', {
  id: text('id').primaryKey().$defaultFn(() => nanoid()),
  postSlug: text('post_slug').notNull(),
  userId: text('user_id').references(() => user.id, { onDelete: 'cascade' }),
  userName: text('user_name').notNull(),
  userEmail: text('user_email').notNull(),
  userAvatar: text('user_avatar'),
  content: text('content').notNull(),
  parentId: text('parent_id').references(() => comment.id, { onDelete: 'cascade' }),
  approved: boolean('approved').notNull().default(false),
  createdAt: timestamp('created_at', { mode: 'date' }).notNull().defaultNow(),
  updatedAt: timestamp('updated_at', { mode: 'date' }).notNull().defaultNow(),
});

export const commentReaction = pgTable('comment_reaction', {
  id: text('id').primaryKey().$defaultFn(() => nanoid()),
  commentId: text('comment_id').notNull().references(() => comment.id, { onDelete: 'cascade' }),
  userId: text('user_id').notNull().references(() => user.id, { onDelete: 'cascade' }),
  type: text('type').notNull(), // 'like', 'love', 'laugh', etc.
  createdAt: timestamp('created_at', { mode: 'date' }).notNull().defaultNow(),
});
```

**Server Actions**ï¼š

```typescript
// src/actions/create-comment.ts
export const createCommentAction = userActionClient
  .schema(z.object({
    postSlug: z.string(),
    content: z.string().min(1).max(1000),
    parentId: z.string().optional(),
  }))
  .action(async ({ parsedInput, ctx }) => {
    const comment = await db.insert(commentTable).values({
      postSlug: parsedInput.postSlug,
      userId: ctx.user.id,
      userName: ctx.user.name,
      userEmail: ctx.user.email,
      userAvatar: ctx.user.image,
      content: parsedInput.content,
      parentId: parsedInput.parentId,
      approved: false, // éœ€è¦å®¡æ ¸
    }).returning();

    return { success: true, comment };
  });

// src/actions/get-comments.ts
export const getCommentsAction = actionClient
  .schema(z.object({ postSlug: z.string() }))
  .action(async ({ parsedInput }) => {
    const comments = await db
      .select()
      .from(commentTable)
      .where(
        and(
          eq(commentTable.postSlug, parsedInput.postSlug),
          eq(commentTable.approved, true)
        )
      )
      .orderBy(desc(commentTable.createdAt));

    return { comments };
  });
```

**è¯„è®ºç»„ä»¶**ï¼š

```typescript
// src/components/comments/comment-section.tsx
'use client';

import { useState, useEffect } from 'react';
import { useAuth } from '@/hooks/use-auth';
import { createCommentAction, getCommentsAction } from '@/actions/comments';

export function CommentSection({ postSlug }) {
  const { user } = useAuth();
  const [comments, setComments] = useState([]);
  const [content, setContent] = useState('');

  useEffect(() => {
    loadComments();
  }, [postSlug]);

  const loadComments = async () => {
    const result = await getCommentsAction({ postSlug });
    setComments(result.data.comments);
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!user) {
      alert('è¯·å…ˆç™»å½•');
      return;
    }

    await createCommentAction({ postSlug, content });
    setContent('');
    loadComments();
  };

  return (
    <div className="mt-16">
      <h2 className="text-2xl font-bold mb-8">è¯„è®º</h2>

      {/* è¯„è®ºè¡¨å• */}
      <form onSubmit={handleSubmit} className="mb-8">
        <textarea
          value={content}
          onChange={(e) => setContent(e.target.value)}
          placeholder="å†™ä¸‹ä½ çš„è¯„è®º..."
          className="w-full p-4 border rounded-lg"
          rows={4}
          required
        />
        <button type="submit" className="mt-2 px-6 py-2 bg-blue-600 text-white rounded-lg">
          æäº¤è¯„è®º
        </button>
      </form>

      {/* è¯„è®ºåˆ—è¡¨ */}
      <div className="space-y-6">
        {comments.map((comment) => (
          <CommentItem key={comment.id} comment={comment} />
        ))}
      </div>
    </div>
  );
}

function CommentItem({ comment }) {
  return (
    <div className="flex gap-4">
      <img
        src={comment.userAvatar || '/default-avatar.png'}
        alt={comment.userName}
        className="w-10 h-10 rounded-full"
      />
      <div className="flex-1">
        <div className="flex items-center gap-2 mb-2">
          <span className="font-semibold">{comment.userName}</span>
          <span className="text-sm text-gray-500">
            {new Date(comment.createdAt).toLocaleDateString()}
          </span>
        </div>
        <p className="text-gray-700">{comment.content}</p>
      </div>
    </div>
  );
}
```

---

## 3. é‚®ç®±è¥é”€ç³»ç»Ÿ

### 3.1 æ‰©å±•ç°æœ‰æ–°é—»è®¢é˜…ç³»ç»Ÿ

#### æ·»åŠ è®¢é˜…è€…ç®¡ç†

```typescript
// src/db/schema.ts
export const newsletterSubscriber = pgTable('newsletter_subscriber', {
  id: text('id').primaryKey().$defaultFn(() => nanoid()),
  email: text('email').notNull().unique(),
  name: text('name'),
  userId: text('user_id').references(() => user.id, { onDelete: 'set null' }),
  status: text('status').notNull().default('active'), // 'active', 'unsubscribed', 'bounced'
  source: text('source'), // 'signup_form', 'user_registration', 'manual'
  tags: jsonb('tags').$type<string[]>(),
  subscribedAt: timestamp('subscribed_at', { mode: 'date' }).notNull().defaultNow(),
  unsubscribedAt: timestamp('unsubscribed_at', { mode: 'date' }),
  createdAt: timestamp('created_at', { mode: 'date' }).notNull().defaultNow(),
  updatedAt: timestamp('updated_at', { mode: 'date' }).notNull().defaultNow(),
});

export const newsletterCampaign = pgTable('newsletter_campaign', {
  id: text('id').primaryKey().$defaultFn(() => nanoid()),
  subject: text('subject').notNull(),
  content: text('content').notNull(),
  status: text('status').notNull().default('draft'), // 'draft', 'scheduled', 'sent'
  scheduledAt: timestamp('scheduled_at', { mode: 'date' }),
  sentAt: timestamp('sent_at', { mode: 'date' }),
  recipientCount: integer('recipient_count').notNull().default(0),
  openedCount: integer('opened_count').notNull().default(0),
  clickedCount: integer('clicked_count').notNull().default(0),
  createdAt: timestamp('created_at', { mode: 'date' }).notNull().defaultNow(),
  updatedAt: timestamp('updated_at', { mode: 'date' }).notNull().defaultNow(),
});
```

#### å‘é€é‚®ä»¶æ´»åŠ¨

```typescript
// src/lib/email-marketing/send-campaign.ts
import { db } from '@/db';
import { newsletterSubscriber, newsletterCampaign } from '@/db/schema';
import { sendEmail } from '@/mail';

export async function sendCampaign(campaignId: string) {
  // è·å–æ´»åŠ¨ä¿¡æ¯
  const campaign = await db
    .select()
    .from(newsletterCampaign)
    .where(eq(newsletterCampaign.id, campaignId))
    .limit(1);

  if (!campaign || campaign.status !== 'scheduled') {
    throw new Error('Campaign not found or not scheduled');
  }

  // è·å–æ‰€æœ‰æ´»è·ƒè®¢é˜…è€…
  const subscribers = await db
    .select()
    .from(newsletterSubscriber)
    .where(eq(newsletterSubscriber.status, 'active'));

  // æ‰¹é‡å‘é€é‚®ä»¶
  for (const subscriber of subscribers) {
    try {
      await sendEmail({
        to: subscriber.email,
        subject: campaign.subject,
        html: personalizeContent(campaign.content, subscriber),
      });

      // è®°å½•å‘é€
      await trackEmail(campaignId, subscriber.id, 'sent');
    } catch (error) {
      console.error(`Failed to send to ${subscriber.email}`, error);
      await trackEmail(campaignId, subscriber.id, 'failed');
    }
  }

  // æ›´æ–°æ´»åŠ¨çŠ¶æ€
  await db
    .update(newsletterCampaign)
    .set({
      status: 'sent',
      sentAt: new Date(),
      recipientCount: subscribers.length,
    })
    .where(eq(newsletterCampaign.id, campaignId));
}

function personalizeContent(content: string, subscriber) {
  return content
    .replace('{{name}}', subscriber.name || 'Friend')
    .replace('{{email}}', subscriber.email);
}
```

### 3.2 é›†æˆä¸“ä¸šé‚®ä»¶è¥é”€æœåŠ¡

#### Resend é«˜çº§åŠŸèƒ½

```typescript
// src/lib/email-marketing/resend-marketing.ts
import { Resend } from 'resend';

const resend = new Resend(process.env.RESEND_API_KEY);

// åˆ›å»ºè”ç³»äºº
export async function addToAudience(email: string, data?: object) {
  await resend.contacts.create({
    email,
    audienceId: process.env.RESEND_AUDIENCE_ID!,
    ...data,
  });
}

// å‘é€è¥é”€é‚®ä»¶
export async function sendMarketingEmail({
  to,
  subject,
  html,
  tags,
}: {
  to: string[];
  subject: string;
  html: string;
  tags?: string[];
}) {
  await resend.emails.send({
    from: 'newsletter@yourdomain.com',
    to,
    subject,
    html,
    tags,
  });
}

// è¿½è¸ªé‚®ä»¶æ‰“å¼€
export async function trackEmailOpen(campaignId: string, subscriberId: string) {
  // Resend è‡ªåŠ¨è¿½è¸ªæ‰“å¼€ç‡
  // é€šè¿‡ webhook æ¥æ”¶äº‹ä»¶
}
```

#### Mailchimp é›†æˆ

```bash
pnpm add @mailchimp/mailchimp_marketing
```

```typescript
// src/lib/email-marketing/mailchimp.ts
import mailchimp from '@mailchimp/mailchimp_marketing';

mailchimp.setConfig({
  apiKey: process.env.MAILCHIMP_API_KEY,
  server: process.env.MAILCHIMP_SERVER_PREFIX,
});

// æ·»åŠ è®¢é˜…è€…
export async function addSubscriber(email: string, tags?: string[]) {
  await mailchimp.lists.addListMember(process.env.MAILCHIMP_LIST_ID!, {
    email_address: email,
    status: 'subscribed',
    tags,
  });
}

// å‘é€æ´»åŠ¨
export async function sendCampaign(campaignId: string) {
  await mailchimp.campaigns.send(campaignId);
}
```

### 3.3 è‡ªåŠ¨åŒ–é‚®ä»¶è¥é”€

#### æ¬¢è¿é‚®ä»¶ç³»åˆ—

```typescript
// src/lib/email-marketing/automation.ts

// ç”¨æˆ·è®¢é˜…æ—¶è§¦å‘æ¬¢è¿é‚®ä»¶ç³»åˆ—
export async function startWelcomeSeries(email: string) {
  // ç«‹å³å‘é€ï¼šæ¬¢è¿é‚®ä»¶
  await sendEmail({
    to: email,
    template: 'welcome',
    subject: 'æ¬¢è¿è®¢é˜…ï¼',
  });

  // 3å¤©åï¼šæ¨èçƒ­é—¨æ–‡ç« 
  await scheduleEmail({
    to: email,
    template: 'popular-posts',
    subject: 'ç²¾é€‰æ–‡ç« æ¨è',
    sendAt: addDays(new Date(), 3),
  });

  // 7å¤©åï¼šé‚€è¯·å…³æ³¨ç¤¾äº¤åª’ä½“
  await scheduleEmail({
    to: email,
    template: 'follow-us',
    subject: 'å…³æ³¨æˆ‘ä»¬è·å–æ›´å¤šæ›´æ–°',
    sendAt: addDays(new Date(), 7),
  });
}
```

#### æ–°æ–‡ç« å‘å¸ƒé€šçŸ¥

```typescript
// å‘å¸ƒæ–°æ–‡ç« æ—¶é€šçŸ¥è®¢é˜…è€…
export async function notifyNewPost(post: Post) {
  const subscribers = await getAllActiveSubscribers();

  await sendEmail({
    to: subscribers.map((s) => s.email),
    template: 'new-post',
    subject: `æ–°æ–‡ç« ï¼š${post.title}`,
    context: {
      postTitle: post.title,
      postExcerpt: post.description,
      postUrl: `https://yourdomain.com/blog/${post.slug}`,
      postImage: post.image,
    },
  });
}
```

#### åŸºäºè¡Œä¸ºçš„è‡ªåŠ¨åŒ–

```typescript
// ç”¨æˆ·é˜…è¯»æ–‡ç« åæ¨èç›¸å…³å†…å®¹
export async function sendRelatedContent(userId: string, postSlug: string) {
  const user = await getUser(userId);
  const relatedPosts = await getRelatedPosts(postSlug);

  // 24å°æ—¶åå‘é€
  await scheduleEmail({
    to: user.email,
    template: 'related-posts',
    subject: 'æ‚¨å¯èƒ½æ„Ÿå…´è¶£çš„æ–‡ç« ',
    context: { posts: relatedPosts },
    sendAt: addHours(new Date(), 24),
  });
}
```

---

## 4. ç”¨æˆ·åˆ†ç»„å’Œæ ‡ç­¾

### 4.1 è®¢é˜…è€…æ ‡ç­¾ç³»ç»Ÿ

```typescript
// æ·»åŠ æ ‡ç­¾
export async function addSubscriberTags(email: string, tags: string[]) {
  await db
    .update(newsletterSubscriber)
    .set({
      tags: sql`${newsletterSubscriber.tags} || ${tags}::jsonb`,
    })
    .where(eq(newsletterSubscriber.email, email));
}

// æ ¹æ®æ ‡ç­¾å‘é€é‚®ä»¶
export async function sendToTaggedSubscribers(tags: string[], emailData) {
  const subscribers = await db
    .select()
    .from(newsletterSubscriber)
    .where(
      and(
        eq(newsletterSubscriber.status, 'active'),
        sql`${newsletterSubscriber.tags} ?| array[${tags.join(',')}]`
      )
    );

  for (const subscriber of subscribers) {
    await sendEmail({ to: subscriber.email, ...emailData });
  }
}
```

### 4.2 ç”¨æˆ·è¡Œä¸ºåˆ†ç»„

```typescript
// æ´»è·ƒè¯»è€…ï¼ˆ30å¤©å†…é˜…è¯»è¿‡3ç¯‡ä»¥ä¸Šæ–‡ç« ï¼‰
// æ–°è®¢é˜…è€…ï¼ˆ7å¤©å†…è®¢é˜…ï¼‰
// ä¸æ´»è·ƒç”¨æˆ·ï¼ˆ90å¤©æœªæ‰“å¼€é‚®ä»¶ï¼‰

export async function segmentUsers() {
  // æ´»è·ƒè¯»è€…
  const activeReaders = await db
    .select()
    .from(newsletterSubscriber)
    .where(
      and(
        eq(newsletterSubscriber.status, 'active'),
        sql`last_opened_at > now() - interval '30 days'`,
        sql`email_opens_count > 3`
      )
    );

  // ä¸æ´»è·ƒç”¨æˆ·
  const inactiveUsers = await db
    .select()
    .from(newsletterSubscriber)
    .where(
      and(
        eq(newsletterSubscriber.status, 'active'),
        sql`last_opened_at < now() - interval '90 days'`
      )
    );

  return { activeReaders, inactiveUsers };
}
```

---

## 5. å®æ–½å»ºè®®

### ç¬¬1é˜¶æ®µï¼šåŸºç¡€è¯„è®ºåŠŸèƒ½

1. **é€‰æ‹©è¯„è®ºç³»ç»Ÿ**ï¼ˆæ¨è Giscusï¼‰
2. **é›†æˆåˆ°åšå®¢é¡µé¢**
3. **æµ‹è¯•å’Œè°ƒæ•´æ ·å¼**

### ç¬¬2é˜¶æ®µï¼šå¢å¼ºæ–°é—»è®¢é˜…

1. **å®Œå–„è®¢é˜…è€…æ•°æ®åº“**
2. **æ·»åŠ æ ‡ç­¾ç³»ç»Ÿ**
3. **å®ç°æ¬¢è¿é‚®ä»¶è‡ªåŠ¨åŒ–**

### ç¬¬3é˜¶æ®µï¼šè¥é”€è‡ªåŠ¨åŒ–

1. **æ–°æ–‡ç« å‘å¸ƒé€šçŸ¥**
2. **ç”¨æˆ·è¡Œä¸ºè¿½è¸ª**
3. **ä¸ªæ€§åŒ–æ¨è**

---

## æ€»ç»“

**å½“å‰çŠ¶æ€**ï¼š
- âŒ æ— è¯„è®ºç³»ç»Ÿ
- âœ… æœ‰æ–°é—»è®¢é˜…ç³»ç»Ÿ
- âœ… ç”¨æˆ·æ³¨å†Œæ—¶è‡ªåŠ¨è®¢é˜…
- âš ï¸ ç¼ºå°‘å®Œæ•´çš„é‚®ä»¶è¥é”€åŠŸèƒ½

**æ¨èæ–¹æ¡ˆ**ï¼š
1. **è¯„è®ºç³»ç»Ÿ**ï¼šGiscusï¼ˆå…è´¹ã€å¼€æºï¼‰
2. **é‚®ä»¶è¥é”€**ï¼šæ‰©å±•ç°æœ‰ Newsletter + Resend
3. **è‡ªåŠ¨åŒ–**ï¼šæ¬¢è¿é‚®ä»¶ã€æ–°æ–‡ç« é€šçŸ¥ã€è¡Œä¸ºè¿½è¸ª

**å…³é”®ä¼˜åŠ¿**ï¼š
- å·²æœ‰ç”¨æˆ·ç³»ç»Ÿå’Œé‚®ç®±æ”¶é›†
- å¯ä»¥åŸºäºç°æœ‰åŸºç¡€å¿«é€Ÿæ‰©å±•
- é€šè¿‡è¯„è®ºå¢åŠ ç”¨æˆ·äº’åŠ¨
- é€šè¿‡é‚®ä»¶è¥é”€æå‡ç•™å­˜
