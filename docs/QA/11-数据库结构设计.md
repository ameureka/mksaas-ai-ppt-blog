# 问题11: 目前的站点使用前端和后端数据库整体是什么？数据库结构是什么如何设计的？

## 技术架构概览

### 前后端集成架构

mksaas-blog 采用 **Next.js 15 全栈架构**，前后端紧密集成：

```
┌──────────────────────────────────────┐
│         客户端 (Client)               │
│   React 19 + TypeScript               │
│   - UI 组件                           │
│   - 客户端状态 (Zustand)              │
│   - React Query 缓存                  │
└──────────────────────────────────────┘
                 ↕
┌──────────────────────────────────────┐
│       Next.js 15 中间层               │
│   - Server Components                │
│   - Server Actions                   │
│   - API Routes                       │
│   - Middleware                       │
└──────────────────────────────────────┘
                 ↕
┌──────────────────────────────────────┐
│     后端业务逻辑层                    │
│   - Authentication (Better Auth)     │
│   - Payment (Stripe)                 │
│   - Credits System                   │
│   - Newsletter                       │
└──────────────────────────────────────┘
                 ↕
┌──────────────────────────────────────┐
│       ORM 层 (Drizzle ORM)           │
│   - Schema 定义                      │
│   - 查询构建器                        │
│   - 关系管理                         │
│   - 迁移管理                         │
└──────────────────────────────────────┘
                 ↕
┌──────────────────────────────────────┐
│       数据库 (PostgreSQL)             │
│   - 用户数据                         │
│   - 支付记录                         │
│   - 积分交易                         │
│   - 会话管理                         │
└──────────────────────────────────────┘
```

---

## 数据库系统

### 1. 数据库选择

**PostgreSQL** (关系型数据库)

**选择原因**:
- ✅ 成熟稳定，企业级
- ✅ 支持复杂查询和事务
- ✅ JSON/JSONB 支持（半结构化数据）
- ✅ 全文搜索
- ✅ 丰富的索引类型
- ✅ 活跃的社区和生态

**连接配置** (`src/db/index.ts`):

```typescript
import { drizzle } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';
import * as schema from './schema';

let cachedDb: ReturnType<typeof drizzle> | null = null;

export async function getDb() {
  if (cachedDb) {
    return cachedDb;
  }

  const connectionString = process.env.DATABASE_URL!;
  const client = postgres(connectionString, { prepare: false });
  cachedDb = drizzle(client, { schema });

  return cachedDb;
}

export const db = await getDb();
```

---

## 数据库架构设计

### 完整 Schema 概览

**文件位置**: `src/db/schema.ts`

```
数据库表结构:

用户和认证相关：
├─ user (用户表)
├─ session (会话表)
├─ account (第三方账户)
└─ verification (验证码表)

支付和订阅相关：
├─ payment (支付记录表)
├─ customer (Stripe 客户表)
├─ userCredit (用户积分表)
└─ creditTransaction (积分交易表)

内容相关：
├─ newsletter_subscriber (新闻订阅者) [需添加]
└─ comment (评论表) [需添加]

配置和日志：
└─ audit_log (审计日志) [需添加]
```

---

## 详细表结构

### 1. 用户表 (user)

**用途**: 存储用户基本信息

```typescript
export const user = pgTable('user', {
  id: text('id').primaryKey().$defaultFn(() => nanoid()),
  name: text('name').notNull(),
  email: text('email').notNull().unique(),
  emailVerified: boolean('email_verified').notNull().default(false),
  image: text('image'),

  // 角色和权限
  role: text('role').notNull().default('user'), // 'user' | 'admin'

  // 封禁管理
  banned: boolean('banned').notNull().default(false),
  banReason: text('ban_reason'),
  banExpires: timestamp('ban_expires', { mode: 'date' }),

  // Stripe 客户 ID
  customerId: text('customer_id'),

  // 审计字段
  createdAt: timestamp('created_at', { mode: 'date' }).notNull().defaultNow(),
  updatedAt: timestamp('updated_at', { mode: 'date' }).notNull().defaultNow(),
});
```

**索引**:
```typescript
// 邮箱唯一索引（自动）
// 角色索引（用于快速查询管理员）
CREATE INDEX idx_user_role ON user(role);

// 封禁状态索引
CREATE INDEX idx_user_banned ON user(banned);
```

**关系**:
- 1:N → session (一个用户多个会话)
- 1:N → account (一个用户多个第三方账户)
- 1:1 → userCredit (一个用户一个积分记录)
- 1:N → payment (一个用户多条支付记录)

---

### 2. 会话表 (session)

**用途**: 管理用户登录会话

```typescript
export const session = pgTable('session', {
  id: text('id').primaryKey().$defaultFn(() => nanoid()),

  // 会话令牌（唯一）
  token: text('token').notNull().unique(),

  // 用户 ID（外键）
  userId: text('user_id')
    .notNull()
    .references(() => user.id, { onDelete: 'cascade' }),

  // 过期时间
  expiresAt: timestamp('expires_at', { mode: 'date' }).notNull(),

  // 设备和位置信息
  ipAddress: text('ip_address'),
  userAgent: text('user_agent'),

  // 管理员伪装（impersonation）
  impersonatedBy: text('impersonated_by'),

  // 审计字段
  createdAt: timestamp('created_at', { mode: 'date' }).notNull().defaultNow(),
  updatedAt: timestamp('updated_at', { mode: 'date' }).notNull().defaultNow(),
});
```

**索引**:
```typescript
CREATE INDEX idx_session_user_id ON session(user_id);
CREATE INDEX idx_session_token ON session(token);
CREATE INDEX idx_session_expires_at ON session(expires_at);
```

---

### 3. 第三方账户表 (account)

**用途**: 存储 OAuth 第三方账户信息

```typescript
export const account = pgTable('account', {
  id: text('id').primaryKey().$defaultFn(() => nanoid()),

  // 用户 ID（外键）
  userId: text('user_id')
    .notNull()
    .references(() => user.id, { onDelete: 'cascade' }),

  // 提供商类型
  provider: text('provider').notNull(), // 'google' | 'github' | 'credential'

  // OAuth 令牌
  accessToken: text('access_token'),
  refreshToken: text('refresh_token'),
  idToken: text('id_token'),
  accessTokenExpiresAt: timestamp('access_token_expires_at', { mode: 'date' }),
  refreshTokenExpiresAt: timestamp('refresh_token_expires_at', { mode: 'date' }),

  // 提供商用户 ID
  providerAccountId: text('provider_account_id').notNull(),

  // 审计字段
  createdAt: timestamp('created_at', { mode: 'date' }).notNull().defaultNow(),
  updatedAt: timestamp('updated_at', { mode: 'date' }).notNull().defaultNow(),
});
```

**索引**:
```typescript
CREATE INDEX idx_account_user_id ON account(user_id);
CREATE UNIQUE INDEX idx_account_provider_account ON account(provider, provider_account_id);
```

---

### 4. 验证表 (verification)

**用途**: 存储验证码（邮箱验证、密码重置）

```typescript
export const verification = pgTable('verification', {
  id: text('id').primaryKey().$defaultFn(() => nanoid()),

  // 标识符（通常是邮箱）
  identifier: text('identifier').notNull(),

  // 验证值（验证码或令牌）
  value: text('value').notNull(),

  // 过期时间
  expiresAt: timestamp('expires_at', { mode: 'date' }).notNull(),

  // 审计字段
  createdAt: timestamp('created_at', { mode: 'date' }).notNull().defaultNow(),
});
```

**索引**:
```typescript
CREATE INDEX idx_verification_identifier ON verification(identifier);
CREATE INDEX idx_verification_value ON verification(value);
```

---

### 5. 支付表 (payment)

**用途**: 存储所有支付记录

```typescript
export const payment = pgTable('payment', {
  id: text('id').primaryKey().$defaultFn(() => nanoid()),

  // 用户 ID（外键）
  userId: text('user_id')
    .notNull()
    .references(() => user.id, { onDelete: 'cascade' }),

  // 价格 ID
  priceId: text('price_id').notNull(),

  // 支付类型
  type: text('type').notNull(), // 'subscription' | 'one_time'

  // 支付场景
  scene: text('scene').notNull(), // 'lifetime' | 'credit' | 'subscription'

  // 支付状态
  status: text('status').notNull(), // 'pending' | 'active' | 'completed' | 'canceled'

  // 是否已支付
  paid: boolean('paid').notNull().default(false),

  // Stripe 相关 ID
  subscriptionId: text('subscription_id'),
  sessionId: text('session_id'),
  invoiceId: text('invoice_id').unique(),

  // 订阅周期
  periodStart: timestamp('period_start', { mode: 'date' }),
  periodEnd: timestamp('period_end', { mode: 'date' }),

  // 试用期
  trialStart: timestamp('trial_start', { mode: 'date' }),
  trialEnd: timestamp('trial_end', { mode: 'date' }),

  // 审计字段
  createdAt: timestamp('created_at', { mode: 'date' }).notNull().defaultNow(),
  updatedAt: timestamp('updated_at', { mode: 'date' }).notNull().defaultNow(),
});
```

**索引**:
```typescript
CREATE INDEX idx_payment_user_id ON payment(user_id);
CREATE INDEX idx_payment_status ON payment(status);
CREATE INDEX idx_payment_type ON payment(type);
CREATE INDEX idx_payment_subscription_id ON payment(subscription_id);
```

---

### 6. 用户积分表 (userCredit)

**用途**: 存储用户当前积分余额

```typescript
export const userCredit = pgTable('user_credit', {
  id: text('id').primaryKey().$defaultFn(() => nanoid()),

  // 用户 ID（外键，唯一）
  userId: text('user_id')
    .notNull()
    .unique()
    .references(() => user.id, { onDelete: 'cascade' }),

  // 当前积分余额
  currentCredits: integer('current_credits').notNull().default(0),

  // 最后刷新时间
  lastRefreshAt: timestamp('last_refresh_at', { mode: 'date' }),

  // 审计字段
  createdAt: timestamp('created_at', { mode: 'date' }).notNull().defaultNow(),
  updatedAt: timestamp('updated_at', { mode: 'date' }).notNull().defaultNow(),
});
```

**索引**:
```typescript
CREATE INDEX idx_user_credit_user_id ON user_credit(user_id);
```

---

### 7. 积分交易表 (creditTransaction)

**用途**: 记录所有积分变动

```typescript
export const creditTransaction = pgTable('credit_transaction', {
  id: text('id').primaryKey().$defaultFn(() => nanoid()),

  // 用户 ID（外键）
  userId: text('user_id')
    .notNull()
    .references(() => user.id, { onDelete: 'cascade' }),

  // 交易类型
  type: text('type').notNull(),
  // 'register_gift' | 'purchase' | 'subscription_grant' |
  // 'monthly_refresh' | 'consume' | 'expire'

  // 积分数量（正数为增加，负数为减少）
  amount: integer('amount').notNull(),

  // 交易描述
  description: text('description'),

  // 交易后剩余积分
  remainingAmount: integer('remaining_amount').notNull(),

  // 关联支付 ID（如果是购买）
  paymentId: text('payment_id').references(() => payment.id),

  // 过期日期（如果有）
  expirationDate: timestamp('expiration_date', { mode: 'date' }),

  // 审计字段
  createdAt: timestamp('created_at', { mode: 'date' }).notNull().defaultNow(),
  updatedAt: timestamp('updated_at', { mode: 'date' }).notNull().defaultNow(),
});
```

**索引**:
```typescript
CREATE INDEX idx_credit_transaction_user_id ON credit_transaction(user_id);
CREATE INDEX idx_credit_transaction_type ON credit_transaction(type);
CREATE INDEX idx_credit_transaction_created_at ON credit_transaction(created_at DESC);
```

---

## 数据库设计原则

### 1. 规范化设计

**第三范式 (3NF)**:
- ✅ 每个表有主键
- ✅ 没有重复的列
- ✅ 非主键列完全依赖于主键

**示例**:
```
❌ 非规范化：
user 表中存储 payment 信息

✅ 规范化：
user 表 + payment 表（通过 userId 关联）
```

### 2. 外键约束

**级联删除** (`onDelete: 'cascade'`):

```typescript
// 删除用户时，自动删除相关数据
userId: text('user_id')
  .references(() => user.id, { onDelete: 'cascade' })

// 数据流:
用户删除 → 会话删除 → 支付记录删除 → 积分记录删除
```

### 3. 索引策略

**创建索引的场景**:
1. **外键**（自动优化 JOIN）
2. **频繁查询的字段**（email, status）
3. **排序字段**（createdAt DESC）
4. **唯一约束**（email, token）

**索引类型**:
```sql
-- B-Tree 索引（默认，适合范围查询）
CREATE INDEX idx_user_created_at ON user(created_at);

-- 唯一索引
CREATE UNIQUE INDEX idx_user_email ON user(email);

-- 复合索引
CREATE INDEX idx_payment_user_status ON payment(user_id, status);

-- 部分索引（只索引特定条件的行）
CREATE INDEX idx_active_payments ON payment(user_id)
WHERE status = 'active';
```

### 4. 数据类型选择

```typescript
// ✅ 推荐的数据类型选择

// ID: text (使用 nanoid，短且唯一)
id: text('id').primaryKey()

// 字符串: text (PostgreSQL 中 text 性能好)
name: text('name')

// 布尔值: boolean
active: boolean('active').default(false)

// 整数: integer
count: integer('count').default(0)

// 金额: integer (存储分，避免浮点数精度问题)
amount: integer('amount') // 990 表示 $9.90

// 日期时间: timestamp
createdAt: timestamp('created_at', { mode: 'date' })

// JSON: jsonb (PostgreSQL 特有，支持索引)
metadata: jsonb('metadata').$type<Record<string, any>>()
```

### 5. 审计字段

**每个表都有**:
```typescript
{
  createdAt: timestamp('created_at').notNull().defaultNow(),
  updatedAt: timestamp('updated_at').notNull().defaultNow(),
}
```

**作用**:
- 追踪数据创建时间
- 追踪数据最后更新时间
- 用于数据分析和排查问题

---

## ORM 层 (Drizzle ORM)

### 1. 为什么选择 Drizzle

**优势**:
- ✅ TypeScript 原生，完美类型推断
- ✅ 无运行时开销
- ✅ SQL-like 查询语法
- ✅ 迁移管理简单
- ✅ 性能优秀

**对比其他 ORM**:

| 特性 | Drizzle | Prisma | TypeORM |
|------|---------|--------|---------|
| 类型安全 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |
| 性能 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ |
| 学习曲线 | 平缓 | 平缓 | 陡峭 |
| 包大小 | 小 | 大 | 大 |
| SQL 控制 | 高 | 中 | 高 |

### 2. 查询示例

**基础查询**:

```typescript
import { db } from '@/db';
import { user, payment } from '@/db/schema';
import { eq, and, desc } from 'drizzle-orm';

// 查询单个用户
const user = await db
  .select()
  .from(user)
  .where(eq(user.email, 'user@example.com'))
  .limit(1);

// 查询用户的所有支付记录
const payments = await db
  .select()
  .from(payment)
  .where(eq(payment.userId, userId))
  .orderBy(desc(payment.createdAt));

// 复杂查询：活跃订阅
const activeSubscriptions = await db
  .select()
  .from(payment)
  .where(
    and(
      eq(payment.userId, userId),
      eq(payment.type, 'subscription'),
      eq(payment.status, 'active'),
      eq(payment.paid, true)
    )
  );
```

**关联查询**:

```typescript
// 用户及其支付记录
const usersWithPayments = await db
  .select()
  .from(user)
  .leftJoin(payment, eq(user.id, payment.userId))
  .where(eq(user.id, userId));
```

**聚合查询**:

```typescript
import { sql, count, sum } from 'drizzle-orm';

// 统计用户总支付金额
const stats = await db
  .select({
    totalPayments: count(),
    totalAmount: sum(payment.amount),
  })
  .from(payment)
  .where(
    and(
      eq(payment.userId, userId),
      eq(payment.paid, true)
    )
  );
```

### 3. 事务处理

```typescript
// 事务：确保原子性
await db.transaction(async (tx) => {
  // 1. 扣除积分
  await tx
    .update(userCredit)
    .set({ currentCredits: sql`current_credits - ${amount}` })
    .where(eq(userCredit.userId, userId));

  // 2. 记录交易
  await tx
    .insert(creditTransaction)
    .values({
      userId,
      type: 'consume',
      amount: -amount,
      description: '消费积分',
    });

  // 如果任何步骤失败，整个事务回滚
});
```

---

## 数据库迁移

### 1. 创建迁移

```bash
# 生成迁移文件
pnpm db:generate

# 应用迁移
pnpm db:migrate

# 直接同步 Schema（开发环境）
pnpm db:push
```

### 2. 迁移文件

**位置**: `drizzle/`

```sql
-- 示例迁移文件
-- 0001_create_user_table.sql

CREATE TABLE IF NOT EXISTS "user" (
  "id" text PRIMARY KEY NOT NULL,
  "name" text NOT NULL,
  "email" text NOT NULL UNIQUE,
  "email_verified" boolean DEFAULT false NOT NULL,
  "created_at" timestamp DEFAULT now() NOT NULL,
  "updated_at" timestamp DEFAULT now() NOT NULL
);

CREATE INDEX "idx_user_email" ON "user" ("email");
```

---

## 数据库配置

**Drizzle 配置** (`drizzle.config.ts`):

```typescript
import { defineConfig } from 'drizzle-kit';

export default defineConfig({
  schema: './src/db/schema.ts',
  out: './drizzle',
  dialect: 'postgresql',
  dbCredentials: {
    url: process.env.DATABASE_URL!,
  },
});
```

---

## 总结

**技术架构**:
- ✅ **前端**: React 19 + TypeScript + Zustand
- ✅ **后端**: Next.js 15 Server Actions
- ✅ **ORM**: Drizzle ORM
- ✅ **数据库**: PostgreSQL

**数据库设计特点**:
- ✅ 规范化设计（3NF）
- ✅ 完整的外键约束
- ✅ 合理的索引策略
- ✅ 审计字段完整
- ✅ 类型安全

**核心表结构**:
1. user (用户)
2. session (会话)
3. account (第三方账户)
4. payment (支付记录)
5. userCredit (用户积分)
6. creditTransaction (积分交易)
7. verification (验证码)

这是一个**企业级的数据库设计**，可扩展性强，性能优秀！
