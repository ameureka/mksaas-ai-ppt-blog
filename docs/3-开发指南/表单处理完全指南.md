# 表单处理完全指南

使用 React Hook Form 和 Zod 构建强大、类型安全的表单。

---

## 快速开始

### 基础表单

```typescript
'use client'

import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'

// 定义 Schema
const loginSchema = z.object({
  email: z.string().email('无效的邮箱'),
  password: z.string().min(6, '密码至少 6 个字符'),
})

type LoginFormData = z.infer<typeof loginSchema>

export function LoginForm() {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm<LoginFormData>({
    resolver: zodResolver(loginSchema),
  })

  async function onSubmit(data: LoginFormData) {
    // 提交表单
    await loginAction(data)
  }

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <label>邮箱</label>
        <input {...register('email')} type="email" />
        {errors.email && <span className="text-red-500">{errors.email.message}</span>}
      </div>

      <div>
        <label>密码</label>
        <input {...register('password')} type="password" />
        {errors.password && <span className="text-red-500">{errors.password.message}</span>}
      </div>

      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? '登录中...' : '登录'}
      </button>
    </form>
  )
}
```

---

## Zod Schema 设计

### 基础类型

```typescript
import { z } from 'zod'

const basicSchema = z.object({
  // 字符串
  name: z.string().min(1, '名字必填').max(100),
  email: z.string().email('邮箱格式错误'),
  password: z.string().min(8).max(128),

  // 数字
  age: z.number().int().min(18, '必须成年'),
  price: z.number().positive('价格必须为正数'),

  // 布尔
  subscribe: z.boolean().default(false),

  // 可选字段
  phoneNumber: z.string().optional(),

  // 可空字段
  nickname: z.string().nullable(),

  // 枚举
  role: z.enum(['user', 'admin', 'moderator']),
})
```

---

### 高级验证

```typescript
// 条件验证
const passwordSchema = z.object({
  password: z.string().min(8),
  confirmPassword: z.string(),
}).refine((data) => data.password === data.confirmPassword, {
  message: '密码不匹配',
  path: ['confirmPassword'],
})

// 异步验证（检查邮箱是否已存在）
const signUpSchema = z.object({
  email: z.string().email(),
}).refine(
  async (data) => {
    const exists = await checkEmailExists(data.email)
    return !exists
  },
  {
    message: '邮箱已被使用',
    path: ['email'],
  }
)

// 条件字段
const conditionalSchema = z.object({
  country: z.enum(['us', 'uk', 'other']),
  state: z.string().optional(), // 仅在 country=us 时必填
  postalCode: z.string().optional(),
}).superRefine((data, ctx) => {
  if (data.country === 'us' && !data.state) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      path: ['state'],
      message: '州必填',
    })
  }
})
```

---

## React Hook Form 高级用法

### 嵌套对象

```typescript
'use client'

import { useForm, Controller } from 'react-hook-form'
import { z } from 'zod'

const profileSchema = z.object({
  personal: z.object({
    firstName: z.string().min(1),
    lastName: z.string().min(1),
  }),
  address: z.object({
    street: z.string(),
    city: z.string(),
    zipCode: z.string(),
  }),
})

type ProfileFormData = z.infer<typeof profileSchema>

export function ProfileForm() {
  const { register, control, handleSubmit, formState: { errors } } = useForm<ProfileFormData>({
    resolver: zodResolver(profileSchema),
  })

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {/* 嵌套字段使用点记号 */}
      <input {...register('personal.firstName')} placeholder="名字" />
      {errors.personal?.firstName && <span>{errors.personal.firstName.message}</span>}

      <input {...register('personal.lastName')} placeholder="姓氏" />

      <input {...register('address.street')} placeholder="街道" />
      <input {...register('address.city')} placeholder="城市" />
      <input {...register('address.zipCode')} placeholder="邮编" />

      <button type="submit">提交</button>
    </form>
  )
}
```

---

### 动态数组字段

```typescript
'use client'

import { useForm, useFieldArray } from 'react-hook-form'

const itemsSchema = z.object({
  items: z.array(z.object({
    name: z.string(),
    quantity: z.number(),
  })),
})

export function OrderForm() {
  const { register, control, handleSubmit } = useForm({
    resolver: zodResolver(itemsSchema),
    defaultValues: {
      items: [{ name: '', quantity: 1 }],
    },
  })

  const { fields, append, remove } = useFieldArray({
    control,
    name: 'items',
  })

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {fields.map((field, index) => (
        <div key={field.id}>
          <input {...register(`items.${index}.name`)} placeholder="商品名" />
          <input {...register(`items.${index}.quantity`, { valueAsNumber: true })} type="number" />
          <button type="button" onClick={() => remove(index)}>
            删除
          </button>
        </div>
      ))}

      <button type="button" onClick={() => append({ name: '', quantity: 1 })}>
        添加商品
      </button>

      <button type="submit">提交订单</button>
    </form>
  )
}
```

---

### 条件字段渲染

```typescript
'use client'

import { useForm, useWatch } from 'react-hook-form'

export function ConditionalForm() {
  const { register, handleSubmit, control } = useForm({
    defaultValues: {
      hasPromoCode: false,
      promoCode: '',
    },
  })

  // 监听字段值变化
  const hasPromoCode = useWatch({
    control,
    name: 'hasPromoCode',
  })

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <label>
        <input {...register('hasPromoCode')} type="checkbox" />
        有优惠码
      </label>

      {/* 条件渲染 */}
      {hasPromoCode && (
        <input
          {...register('promoCode')}
          placeholder="输入优惠码"
          required={hasPromoCode}
        />
      )}

      <button type="submit">提交</button>
    </form>
  )
}
```

---

## 集成 Server Actions

### 带验证的 Server Action

```typescript
// src/actions/user.ts
'use server'

import { z } from 'zod'
import { db } from '@/db'
import { auth } from '@/lib/auth'

const updateProfileSchema = z.object({
  name: z.string().min(1).max(100),
  bio: z.string().max(500),
})

export async function updateProfile(data: z.infer<typeof updateProfileSchema>) {
  try {
    // 验证
    const validData = updateProfileSchema.parse(data)

    // 权限检查
    const session = await auth()
    if (!session?.user) {
      throw new Error('未登录')
    }

    // 更新数据库
    const updated = await db.update(user).set(validData)

    return { success: true, user: updated }
  } catch (error) {
    if (error instanceof z.ZodError) {
      return { success: false, errors: error.flatten() }
    }
    return { success: false, error: '更新失败' }
  }
}
```

---

### 在组件中使用

```typescript
'use client'

import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { updateProfile } from '@/actions/user'

const schema = z.object({
  name: z.string().min(1),
  bio: z.string().max(500),
})

export function EditProfileForm({ user }: { user: User }) {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm({
    resolver: zodResolver(schema),
    defaultValues: {
      name: user.name,
      bio: user.bio,
    },
  })

  async function onSubmit(data: z.infer<typeof schema>) {
    const result = await updateProfile(data)

    if (!result.success) {
      alert('更新失败')
      return
    }

    alert('更新成功')
  }

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register('name')} />
      {errors.name && <span className="text-red-500">{errors.name.message}</span>}

      <textarea {...register('bio')} />
      {errors.bio && <span className="text-red-500">{errors.bio.message}</span>}

      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? '保存中...' : '保存'}
      </button>
    </form>
  )
}
```

---

## 文件上传

```typescript
'use client'

import { useForm, Controller } from 'react-hook-form'
import { z } from 'zod'

const fileSchema = z.object({
  file: z.instanceof(FileList).refine((files) => files.length > 0, '必须选择文件'),
})

export function FileUploadForm() {
  const { register, handleSubmit, formState: { errors } } = useForm({
    resolver: zodResolver(fileSchema),
  })

  async function onSubmit(data: z.infer<typeof fileSchema>) {
    const formData = new FormData()
    formData.append('file', data.file[0])

    const response = await fetch('/api/uploads', {
      method: 'POST',
      body: formData,
    })

    const result = await response.json()
    console.log('上传结果:', result)
  }

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register('file')} type="file" accept="image/*" />
      {errors.file && <span className="text-red-500">{errors.file.message}</span>}

      <button type="submit">上传</button>
    </form>
  )
}
```

---

## 多步骤表单

```typescript
'use client'

import { useState } from 'react'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'

// 分步 Schema
const step1Schema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
})

const step2Schema = z.object({
  name: z.string().min(1),
  phone: z.string(),
})

export function MultiStepForm() {
  const [step, setStep] = useState(1)
  const [formData, setFormData] = useState({})

  const form = useForm({
    resolver: zodResolver(step === 1 ? step1Schema : step2Schema),
  })

  async function onStep1Submit(data: z.infer<typeof step1Schema>) {
    setFormData({ ...formData, ...data })
    setStep(2)
  }

  async function onStep2Submit(data: z.infer<typeof step2Schema>) {
    const completeData = { ...formData, ...data }
    // 提交最终数据
    await submitForm(completeData)
  }

  return (
    <form onSubmit={form.handleSubmit(step === 1 ? onStep1Submit : onStep2Submit)}>
      <h2>步骤 {step} / 2</h2>

      {step === 1 && (
        <>
          <input {...form.register('email')} placeholder="邮箱" />
          <input {...form.register('password')} type="password" placeholder="密码" />
        </>
      )}

      {step === 2 && (
        <>
          <input {...form.register('name')} placeholder="名字" />
          <input {...form.register('phone')} placeholder="电话" />
        </>
      )}

      <div className="flex gap-4">
        {step > 1 && (
          <button type="button" onClick={() => setStep(step - 1)}>
            上一步
          </button>
        )}
        <button type="submit">
          {step === 2 ? '完成' : '下一步'}
        </button>
      </div>
    </form>
  )
}
```

---

## 自动保存（草稿）

```typescript
'use client'

import { useState, useEffect, useRef } from 'react'
import { useForm } from 'react-hook-form'
import { useDebounce } from '@/hooks/useDebounce'

export function AutoSaveForm() {
  const { register, watch } = useForm()
  const [isSaving, setIsSaving] = useState(false)
  const [lastSaved, setLastSaved] = useState<Date | null>(null)

  const formValues = watch()
  const debouncedValues = useDebounce(formValues, 1000)

  useEffect(() => {
    // 自动保存
    const saveDraft = async () => {
      setIsSaving(true)
      try {
        await saveDraftAction(debouncedValues)
        setLastSaved(new Date())
      } finally {
        setIsSaving(false)
      }
    }

    if (Object.keys(debouncedValues).length > 0) {
      saveDraft()
    }
  }, [debouncedValues])

  return (
    <div>
      <form>
        <textarea {...register('content')} placeholder="开始输入..." />
      </form>

      {isSaving && <span>保存中...</span>}
      {lastSaved && (
        <span className="text-gray-500">
          最后保存: {lastSaved.toLocaleTimeString()}
        </span>
      )}
    </div>
  )
}
```

---

## 性能优化

### 懒验证

```typescript
'use client'

import { useForm } from 'react-hook-form'

export function LazyValidationForm() {
  const { register, formState: { errors } } = useForm({
    mode: 'onBlur', // 仅在失焦时验证，不是实时验证
  })

  return (
    <form>
      <input {...register('email')} type="email" />
      {errors.email && <span>{errors.email.message}</span>}
    </form>
  )
}
```

---

### 减少不必要重渲染

```typescript
'use client'

import { useForm, useWatch, Controller } from 'react-hook-form'

export function OptimizedForm() {
  const { control, handleSubmit } = useForm()

  // 只重新渲染特定字段
  const watchedEmail = useWatch({
    control,
    name: 'email',
  })

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {/* 其他字段不会因为 email 改变而重新渲染 */}
      <input name="email" value={watchedEmail} onChange={...} />
    </form>
  )
}
```

---

## 常见问题

### Q: 如何显示服务器错误?

```typescript
async function onSubmit(data: FormData) {
  const result = await updateProfile(data)

  if (!result.success) {
    // 显示服务器返回的错误
    setErrors(result.errors)
  }
}
```

---

### Q: 如何清空表单?

```typescript
const { reset } = useForm()

function clearForm() {
  reset() // 清空所有字段
  reset({ name: '' }) // 只清空特定字段
}
```

---

### Q: 如何设置默认值?

```typescript
const user = await getUser()

const { register } = useForm({
  defaultValues: {
    name: user.name,
    email: user.email,
  },
})
```

---

## 总结

✅ **Zod Schema** - 类型安全的验证
✅ **React Hook Form** - 高性能表单管理
✅ **异步验证** - 检查邮箱是否已存在
✅ **条件字段** - 动态表单
✅ **文件上传** - 处理二进制数据
✅ **多步骤** - 分步提交
✅ **自动保存** - 草稿功能
✅ **性能优化** - 懒验证、减少重渲染

---

**相关文档:**
- [Server Actions 详解](./Server Actions详解.md)
- [自定义 Hooks](./自定义Hooks.md)

**最后更新:** 2025-11-18
